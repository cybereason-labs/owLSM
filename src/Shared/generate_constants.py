#!/usr/bin/env python3
import json
import sys
from pathlib import Path


def generate_header(json_path: Path, output_path: Path) -> None:
    with open(json_path, 'r') as f:
        constants = json.load(f)
    
    lines = [
        "#pragma once",
        "",
        "/**",
        " * @file constants.h",
        " * @brief Auto-generated constants from constants.json",
        " * ",
        " * DO NOT EDIT THIS FILE MANUALLY!",
        " * Run 'make generate_constants' or 'python3 scripts/generate_constants.py' to regenerate.",
        " */",
        "",
        "// =============================================================================",
        "// Macros",
        "// =============================================================================",
        "",
    ]
    
    # Process top-level key-value pairs as #define macros
    for key, value in constants.items():
        if isinstance(value, (int, float)):
            lines.append(f"#define {key} {value}")
    
    lines.append("")
    lines.append("// =============================================================================")
    lines.append("// Enums")
    lines.append("// =============================================================================")
    
    if "operator_types" in constants:
        lines.append("")
        lines.append("enum operator_types {")
        operator_types = constants["operator_types"]
        for i, key in enumerate(operator_types.keys()):
            comma = "," if i < len(operator_types) - 1 else ""
            lines.append(f"    {key} = {i}{comma}")
        lines.append("};")
    
    # Process actions (array format)
    if "actions" in constants:
        lines.append("")
        lines.append("enum rule_action {")
        actions = constants["actions"]
        for i, action in enumerate(actions):
            comma = "," if i < len(actions) - 1 else ""
            lines.append(f"    {action} = {i}{comma}")
        lines.append("};")
    
    # Process file_types (dict with explicit numeric values)
    if "file_types" in constants:
        lines.append("")
        lines.append("enum file_type {")
        file_types = constants["file_types"]
        items = list(file_types.items())
        for i, (key, value) in enumerate(items):
            comma = "," if i < len(items) - 1 else ""
            lines.append(f"    {key} = {value}{comma}")
        lines.append("};")
    
    # Process connection_direction (dict with explicit numeric values)
    if "connection_direction" in constants:
        lines.append("")
        lines.append("enum connection_direction {")
        connection_dir = constants["connection_direction"]
        items = list(connection_dir.items())
        for i, (key, value) in enumerate(items):
            comma = "," if i < len(items) - 1 else ""
            lines.append(f"    {key} = {value}{comma}")
        lines.append("};")
    
    # Process comparison_types
    if "comparison_types" in constants:
        lines.append("")
        lines.append("enum comparison_type {")
        comparison_types = constants["comparison_types"]
        for i, key in enumerate(comparison_types.keys()):
            comma = "," if i < len(comparison_types) - 1 else ""
            lines.append(f"    {key} = {i}{comma}")
        lines.append("};")
    
    # Process rule_field_types (dot-notation -> UPPER_SNAKE_CASE)
    if "rule_field_types" in constants:
        lines.append("")
        lines.append("enum rule_field_type {")
        rule_fields = constants["rule_field_types"]
        keys = list(rule_fields.keys())
        for i, key in enumerate(keys):
            enum_name = key.upper().replace(".", "_")
            comma = "," if i < len(keys) - 1 else ""
            lines.append(f"    {enum_name}{comma}")
        lines.append("};")
    
    lines.append("")
    
    # Write output
    content = "\n".join(lines)
    output_path.write_text(content)
    print(f"Generated {output_path}")


def main():
    # Determine paths relative to script location
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    
    json_path = repo_root / "Shared" / "constants.json"
    output_path = repo_root / "Shared" / "constants.h"
    
    if not json_path.exists():
        print(f"Error: {json_path} not found", file=sys.stderr)
        sys.exit(1)
    
    generate_header(json_path, output_path)


if __name__ == "__main__":
    main()

