The flow of handling event is very simple.
At ProbeManager::bpfAttach we start the ringbuffers.
THe EBPF program writes the event to the ringbuffer.
The in the files src/Userspace/ringbuffers_messages_handlers.* we handle the events and error messages.
The current handling is just taking the event and converting it to a JSON before writing it to the file descriptor.

Now I want to add a more sophisticated handling of the events.
See docs/EventEnrichment/shell_builtin_command_uprobes_design.drawio and docs/EventEnrichment/shell_builtin_command_uprobes_design.drawio.png for basic flow.

# High level design
We need to convert the event_t to a shared pointer of a C++ object.
The we can free the event_t

Add a class called SyncEventEnrichment
it will be in charge of enriching the event.
It will take the shared pointer of the event and enrich it.
Things like:
- matched rule metadata

Add a class called AsyncEvenWorkDistributor
It will be in charge of deciding if async work is needed, and if so what extra work.
It will either tag the event with what async work is needed, or just move it to relevant queues.

Print the enriched event to the file descriptor.
Similar to how we do it now with src/Userspace/parse_events.cpp

For error messages, no extra work is needed. Just take the error_report_t and print it to the file descriptor.

# Steps to implement the new flow
1) Create a C++ struct called Event
- Is should mirror all the fields of the event_t.
    + Add corrsponding sub structs as well.
- It should have the following new fields:
    + matched_rule_metadata of type owlsm::config::RuleMetadata
- the struct should have a constructor that takes the event_t and converts it to the struct.
    + it should have the default constructor as well.
- It should have a member called is_enriched of type bool.
- instead of union, use std::variant.

2) Create a C++ struct called Error
- same file as Event struct
- Is should have all the fields of the error_report_t in the same structure.
    + the struct should have a constructor that takes the error_report_t and converts it to the struct.
    + it should have the default constructor as well.
- It should have a member called is_enriched of type bool.

3) Create C++ classes SyncEventEnrichment and SyncErrorEnrichment
- Has a function called Enrich that takes the shared pointer of the Event/Error and enriches it.
    + It will enrich the event with the matched rule metadata.
    + For errors, it will not do anything.
- remove this from main owlsm::RulesMetadataTracker rules_metadata_tracker(owlsm::globals::g_config.rules_config.rules);
-  SyncEventEnrichmentshould have a memeber m_rules_metatadata
    + the constructor should do something similar to what main had 

4) Create a C++ class called AsyncEventWorkDistributor and AsyncErrorWorkDistributor
- Has a function called Distribute that takes the shared pointer of the Event/Error and currently does nothing.

5) Create new files for parse_events.* 
- They should be called parse_messages.*
- Currently they just need to take the shared pointer and print it to the file descriptor.
- I want the current output to look exactly the same as old parse_events.*, so you should not change the output format.
    + Even keep the functions names 

6) Create a Template class called RingbufferMessagesHandler<MessageType, SyncEnrichments, AsyncWorkDistributor>
- MessageType is Event or Error
- It should have the same interface as RingbuffersMessagesHandlers.
- It should try and mimic the current flow as much as possible.
- Instead of working on m_thread_queue, create another queue for MessageType struct. Called m_messages_queue.
    + Convert all the event_t/error_report_t in m_thread_queue to MessageType struct and push them to m_messages_queue. 
    Use std::transform(m_thread_queue.begin(), m_thread_queue.end(),m_messages_queue.begin(),[](const event_t& ev){return std::make_shared<Event>(ev); }
);
    If this is something that can be done automatically via swap() amazing. If not think what is the best way to do it.
- Add another members for SyncEnrichments and AsyncWorkDistributor.
    + Iterate over m_messages_queue and pass them to SyncEnrichments.Enrich()
- Make build_output_buffer take the shared pointer 
- After efficient_bulk_write, iterate over m_messages_queue and pass them to AsyncWorkDistributor.Distribute()
- after everything is done, clear m_messages_queue.

7) Make ProbeManager::bpfAttach use the new RingbufferMessagesHandler.

8) After I see everything works as expected I will ask you what old code I should delete
- parse_events.* files
- Old SpecificRingbufferHandler and RingbuffersMessagesHandlers classes.
- includes of old code

9) struct Event, matched rule metadata:
Event already has config::RuleMetadata matched_rule_metadata;
Now we need to print it in the json.


# Instructions to LLM
- We are going to implement one/multiple steps at a time. I will specify what steps to implement each time.
- If you get stuck, stop and ask me for help.
- Try keep things simple
- Before starting a step, if you aren't sure about something important please ask me.
- All the new file should be in src/Userspace/events as they are event related
- When you try to compile use "make clean; make -j$(nproc)" Or "make clean; make test -j$(nproc);"
- Always try to delegate work to 3rd party code under src/Userspace/3rd_party. Or if you think a new 3rd party library/code can really help, let me know and I will add it.


# questions to LLM
- What do you think about my plan?
- Is their anything that you don't understand?
- Is their anything you think can be done better?